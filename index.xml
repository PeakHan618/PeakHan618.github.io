<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Linguage</title>
    <link>https://peakhan618.github.io/</link>
    <description>Recent content in Home on Linguage</description>
    <generator>Hugo 0.125.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 19 Apr 2024 20:50:12 +0800</lastBuildDate>
    <atom:link href="https://peakhan618.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Modern Fortran 附录</title>
      <link>https://peakhan618.github.io/books/modernfortran/appendix/</link>
      <pubDate>Fri, 19 Apr 2024 20:50:12 +0800</pubDate>
      <guid>https://peakhan618.github.io/books/modernfortran/appendix/</guid>
      <description></description>
    </item>
    <item>
      <title></title>
      <link>https://peakhan618.github.io/books/modernfortran/moderfortran-0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://peakhan618.github.io/books/modernfortran/moderfortran-0/</guid>
      <description>前言 得知米兰·库尔奇克将要写一本现代Fortran的书，我立刻感到兴奋。几乎每周，我都会遇到人们对于Fortran在其诞生60多年后仍然在使用感到惊讶，因此，任何对一个经常被认为已经死亡或濒临消亡的语言出现新生机的迹象都是值得庆祝的。我通常会解释说，Fortran在早期接受计算机的领域中占据着最强大的地位。我会继续告诉他们，当他们每天检查天气预报时，几乎肯定会使用Fortran程序的结果。米兰的工作之所以令人着迷，是因为它将长期以来Fortran占据主导地位的已建立领域与Fortran稀缺的新兴领域联系起来。这本书源于米兰独特的视角，他一直致力于弥合阻止许多学科写作Fortran的鸿沟，并阻止大多数Fortran程序员利用其他语言中已广泛使用的编程范式。&#xA;值得赞扬的是，这本书侧重于教授Fortran编程，而不是推广他所贡献的有趣的软件库和应用程序。那些跟随他的工作以及其他人的链接的幸运读者将获得的不仅仅是对Fortran编程的理解。这样的读者将踏上一段旅程，将数值天气预报（作为一门与计算同样古老的学科）与云计算（二十一世纪的创新）联系起来。这样的读者还将发现如何在Fortran中融入函数式编程的方面，这是一个整个语言都围绕着建立的编程范式，而Fortran则是所有高级编程语言的最终祖先。这样的读者还将暴露于神经网络的知识中，这是一个正在经历爆炸式增长并影响着诸如自动驾驶和癌症诊断等截然不同的技术的领域。&#xA;米兰在这些领域中领导或贡献了一些流行的软件，其中一些软件包源于这本书，或者反之亦然。例如，他与他人共同开发的服务Cloudrun(https://cloudrun.co)开创了使用云计算平台进行数值天气预报软件即服务（SaaS）的先河。开源的functional-fortran库(http://mng.bz/vxy1)提供了支持一种编程范式的实用工具，这种编程范式在Fortran世界中的普及程度不如我所希望的那样高。开源的Fortran标准库（https://github.com/fortran-lang/stdlib）旨在使Fortran与其他语言更加平等，这些语言受益于被视为语言一部分的大型库。他的neural-fortran（https://github.com/modern-fortran/neural-fortran）是从他在本书的一章中的工作中发展而来的，它展示了Fortran可扩展并行编程模型在一个由缺乏内置并行编程模型以利用分布式内存平台的语言主导的领域中的应用。总的来说，这些项目被全球数百名开发人员使用，他在这本书上的工作与这些项目的工作相互影响和启发了书中对语言的覆盖。&#xA;对于寻求现代Fortran生机的读者，米兰的工作为这种语言在技术现代化中持续发挥作用提供了充分的证据。这本书是他工作中生长出的更有活力的芽之一，感兴趣的读者将学到在米兰的广泛项目组合中已被证明有用的语言特性。&#xA;——DAMIAN ROUSON，&#xA;博士，P.E. 董事长，Sourcery Institute，加利福尼亚州奥克兰，美国&#xA;序言 2017年夏天，曼宁出版社的迈克·斯蒂芬斯（Mike Stephens）首次与我联系时写道：“我们看到了你的一些论坛帖子和GitHub仓库；你考虑过和曼宁一起写一本Fortran书吗？”写书从未在我的脑海中出现过，我也不认为自己适合这个工作。我闭上眼睛，做了一个信任的飞跃。“当然，我很愿意！我把提案发送到哪里呢？”夏天结束时，我们签订了合同，并制定了初步的目录。经过两名开发编辑、两名技术编辑、四次同行评审、三次章节重写、两次飓风的影响，以及将近三年的时间，我们完成了这本书。&#xA;欢迎来到《现代Fortran：构建高效的并行应用》！如果你拿着这本书，很可能你要么想要学习Fortran编程以应对学校或工作的需要，要么你是一位经验丰富的Fortran程序员，想要了解该语言的最新发展。无论哪种情况，你来对地方了。如果你刚开始学习，我希望这本书能为你提供一种简单、动手实践的实用Fortran编程方法。如果你已经有了使用该语言的经验，我希望这本书能成为你在Fortran世界中的实用指南。忘记如何编写既能操作标量又能操作数组的函数了吗？想知道如何为并行执行编写程序？这里有实用的项目和练习，以及解决方案，来帮助你理解。&#xA;我很高兴有机会与你分享我在过去14年里学到的东西。提前感谢你信任我，花费时间和金钱阅读这本书。《现代Fortran》是我回报给那些教导我、帮助过我的人的方式。我希望你能利用这本书来培养下一代Fortran程序员。&#xA;致谢 要完成一本优秀的书籍，需要整个团队的努力。迈克·斯蒂芬斯是采编编辑，他邀请我加入，并帮助制定了目录，确定了这本书的读者群。我的开发编辑克里斯汀·瓦特森（Kristen Watterson）和莱斯利·特里特斯（Lesley Trites）在整个过程中给予我指导，并不懈地推动我前进。克里斯汀与我一起起草了九章的初稿；然后莱斯利接手了剩下的工作，并将所有内容整合在一起。技术编辑米歇尔·特里姆普（Michiel Trimpe）和阿兰·库尼奥（Alain Couniot）确保指出了代码中的任何错误和令人困惑的段落。伯特·贝茨（Bert Bates）偶尔会加入，帮助我从抽象中提炼出具体内容。毛里齐奥·托马西（Maurizio Tomasi）是技术校对员，确保书中的所有代码都能正常运行。梅洛迪·多拉布（Melody Dolab）担任最终校对，洛里·韦德特（Lori Weidert）担任制作编辑。还要感谢曼宁其他与我合作的工作人员：坎迪斯·吉尔胡利（Candace Gillhoolley）、安娜·罗马克（Ana Romac）、雷哈娜·马尔卡诺维奇（Rejhana Markanovic）、亚历山大·德拉戈萨维里耶维奇（Aleksandar Dragosavljevic）、马特科·赫瓦汀（Matko Hrvatin）等等。谢谢你们，我从你们身上学到了很多。&#xA;我还要感谢所有的审阅者：安德斯·约翰松（Anders Johansson）、安东·门舒夫（Anton Menshov）、布里奇尔·豪威尔（Bridger Howell）、大卫·克莱门斯（David Celements）、达维德·卡达穆罗（Davide Cadamuro）、弗雷德里克·拉格纳（Fredric Ragnar）、简·皮特·赫韦尔（Jan Pieter Herweijer）、何塞·圣莱安德罗（Jose San Leandro）、约瑟夫·伊恩·沃克（Joseph Ian Walker）、卡纳克·克谢特里（Kanak Kshetri）、肯·W·阿尔杰（Ken W. Alger）、康拉德·欣森（Konrad Hinsen）、凯尔·曼德利（Kyle Mandli）、莱昂纳多·科斯塔·普劳奇纳（Leonardo Costa Prauchner）、洛蒂·格林伍德（Lottie Greenwood）、路易斯·穆·多明格斯（Luis MouxDomínguez）、马尔西奥·尼科劳（Marcio Nicolau）、马丁·比尔（Martin Beer）、马修·埃米特（Matthew Emmett）、毛里齐奥·托马西（Maurizio Tomasi）、迈克尔·詹森（Michael Jensen）、米哈尔·康拉德·奥维亚克（Michal Konrad Owsiak）、米克尔·阿伦托夫特（Mikkel Arentoft）、翁德雷·切尔蒂克（Ondrˇej Cˇertík）、帕特里克·西沃尔德（Patrick Seewald）、理查德·菲尔森德（Richard Fieldsend）、瑞安·B·哈维（Ryan B. Harvey）、斯尔德扬·桑蒂奇（Srdjan Santic）、斯蒂法诺·博里尼（Stefano Borini）、蒂齐亚诺·穆勒（Tiziano Müller）、汤姆·格思（Tom Gueth）、瓦尔米基·阿奎萨达斯（Valmiky Arquissandas）以及文森特·扎巴拉（Vincent Zaballa）。你们的建议帮助了这本书的完善。</description>
    </item>
    <item>
      <title></title>
      <link>https://peakhan618.github.io/books/modernfortran/modernfortran-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://peakhan618.github.io/books/modernfortran/modernfortran-1/</guid>
      <description>第 1 部分 开始学习现代 Fortran 在这一部分，你将品尝一下 Fortran，并初步了解这门语言。在第 1 章中，我们将讨论 Fortran 的设计和特性，以及适合使用 Fortran 的问题类型。你将了解到为什么并行编程很重要，以及何时应该使用它。在第 2 章中，我们将构建一个海啸模拟器的最小工作示例，这个示例将贯穿整本书。这个示例将让你初步了解 Fortran 的基本要素：变量声明、数据类型、数组、循环和分支。如果你是 Fortran 的新手，这是一个很好的开始。在本书的这一部分结束时，你将能够编写简单但实用的 Fortran 程序。更重要的是，你将准备好更深入地学习 Fortran 的基本要素。&#xA;第1章 介绍 Fortran 本章内容包括&#xA;什么是 Fortran 以及为什么要学习它？ Fortran 的优势和劣势 并行思维 从零开始构建并行模拟应用程序 这是一本关于 Fortran 的书，它是历史上最早的高级编程语言之一。本书将通过逐步引导您开发一个功能齐全的并行物理模拟应用程序来教授您这种语言。请注意重点是并行化。并行编程允许您将问题分解成多个部分，并让多个处理器分别处理问题的一部分，从而在较短的时间内达到解决问题的目的。到最后，您将能够识别可以并行化的问题，并使用现代 Fortran 技术来解决它们。&#xA;本书并不是每个 Fortran 特性的全面参考手册，我故意省略了语言的重要部分。相反，我专注于您用于构建实际 Fortran 应用程序的最实用的特性。随着我们逐章开发我们的应用程序，我们将应用现代 Fortran 特性和软件设计技术，使我们的应用程序强大、可移植、易于使用并且易于扩展。这不仅仅是一本关于 Fortran 的书；它是一本关于使用现代 Fortran 构建强大的并行软件的书。&#xA;1.1 什么是 Fortran？ “我不知道 2000 年的编程语言会是什么样子，但我知道它将被称为 Fortran。”&#xA;—— 托尼·霍尔（Tony Hoare），1980 年图灵奖获得者&#xA;Fortran 是一种通用的、并行的编程语言，在科学和工程应用中表现出色。最初于 1957 年被称为 FORTRAN（FORmula TRANslation），经过数十年的发展，它已经成为一种稳健、成熟、面向高性能的编程语言。如今，Fortran 在许多我们视为理所当然的系统中仍然发挥作用：&#xA;数值天气、海洋和浪涌预测 气候科学和预测 机械和土木工程中使用的计算流体力学软件 用于设计汽车、飞机和航天器的空气动力学求解器 机器学习框架使用的快速线性代数库 对世界上最快的超级计算机进行基准测试( https://top500.</description>
    </item>
    <item>
      <title></title>
      <link>https://peakhan618.github.io/books/modernfortran/modernfortran_2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://peakhan618.github.io/books/modernfortran/modernfortran_2/</guid>
      <description>第2章 入门：最小可行应用 本章涵盖&#xA;编译和运行你的第一个Fortran程序 数据类型、声明、算术和控制流 构建和运行你的第一个模拟应用 在本章中，我们将实现海啸模拟器的最小可行版本。为简单起见，我们将从模拟水在空间中的移动开始，而不改变其形状。这个问题足够复杂，可以介绍Fortran的基本要素：数值数据类型、声明、算术表达式和赋值，以及控制流。一旦我们成功地在本章中模拟了对象的移动，我们将重构代码，在第3章和第4章中添加其他物理过程，从而使模拟的水流动更加真实。实现其他过程将更容易，因为我们将能够重用在本章中编写的大部分代码。&#xA;我们将从编译、链接和运行你的第一个Fortran程序开始。然后，我将介绍我们想要解决的物理问题，并向你展示如何将其表达为计算机程序的形式。接着，我们将深入探讨Fortran的基本要素：数据类型、声明、算术和控制流。在本章结束时，你将具备编写基本但实用的Fortran程序的工作知识。&#xA;2.1 编译和运行你的第一个程序 让我们首先创建、编译和运行你的第一个Fortran程序。我假设你已经在系统上安装了GNU Fortran编译器（gfortran）。如果还没有安装，请按照附录A中的说明进行设置。&#xA;当你安装了编译器后，请通过编译和运行你的第一个Fortran程序来测试它，如下面的示例所示。&#xA;程序2.1 您的第一个Fortran程序：hello.f90&#xA;! 开始程序并为其命名 program hello ! 向终端打印简短的问候语 print *, &amp;#39;Hello world!&amp;#39; ! 结束程序 end program hello 这个程序只做一件事情——向终端打印一条简短的问候信息，这是大多数编程书籍中第一个示例的常见做法。让我们将其保存在名为 hello.f90 的文件中。编译非常简单，只需将源文件传递给编译器，可选地指定输出（-o）可执行文件的名称：&#xA;gfortran hello.f90 -o hello 如果您不使用 -o 指定输出文件的名称，则可执行文件的名称默认为 a.out。&#xA;运行程序会产生预期的输出：&#xA;./hello # 通过输入可执行文件名运行程序 Hello world! # 程序在终端中的输出 这就是全部——你编写并编译了你的第一个Fortran程序！让我们看看在幕后发生了什么。构建程序通常涉及两个步骤： 1 编译 — 编译器解析高级语言（这里是Fortran）的源代码，并输出相应的一组机器指令。在我们的情况下，gfortran将读取带有 .f90 后缀的Fortran源文件，并输出一个相应的二进制对象文件，其后缀为 .o。大多数编译器都接受其他源文件的后缀，如 .f、.f03 或 .f08；然而，为了保持一致性，我建议坚持使用 .f90。 2 链接 — 二进制对象文件（.o），是编译步骤的结果，本身无法执行。链接器通常由编译器在幕后调用，将二进制对象文件组合成一个或多个可执行程序。&#xA;要构建我们的第一个程序，我们只需输入一个命令，即 gfortran hello.f90 -o hello，这意味着没有将编译和链接分为两个独立的步骤。当整个程序包含在一个单独的文件中时，将编译和链接步骤组合在一个命令中就足够了。该命令等同于以下程序。</description>
    </item>
    <item>
      <title></title>
      <link>https://peakhan618.github.io/books/modernfortran/modernfortran_3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://peakhan618.github.io/books/modernfortran/modernfortran_3/</guid>
      <description>第二部分 Fortran的核心要素 本部分涵盖了Fortran的核心要素：过程、模块、数组和I/O。&#xA;在第3章中，您将学习有关函数和子程序（统称为过程）的最重要的知识。它们将使您能够抽象出需要多次运行的任何代码片段。函数和子程序是基本构建模块，使您能够编写可重用、可组合且复杂（但不复杂）的代码。您将应用这些知识来重构我们在第2章中开始的海啸模拟器。&#xA;在第4章中，您将了解模块以及如何使用它们来组织您的数据和过程，形成可重用和可移植的组件。&#xA;第5章涵盖了数组，这是Fortran的基本数据结构。您将学习如何声明、初始化和使用数组，以及如何利用整个数组算术来极大简化您的代码。您将使用数组分析股价时间序列。&#xA;最后，第6章涵盖了I/O。您将学习如何从标准输入、输出和错误流中读取和写入数据，以及如何从磁盘文件中读取和写入数据。您还将学习如何将数字数据格式化为文本。您将通过为命令行编写一个最小的笔记应用程序来练习这些技能。&#xA;通过学习本书的这一部分，并进行一些练习，您将成为一个功能齐全且独立的Fortran程序员。您将能够从头开始编写Fortran程序和库来解决现实世界的问题。&#xA;第3章 使用函数和子程序编写可重用代码 本章涵盖了以下内容：&#xA;过程是什么以及为什么我们使用它们 过程分为两种类型：函数和子程序 编写不引起副作用的过程 编写适用于标量和数组的过程 在上一章中，您学习了Fortran的核心要素：标量和数组变量的声明、使用do循环迭代代码部分指定次数以及算术表达式和赋值。我们利用这些要素编写了一个简单的模拟器，用于预测由背景流引起的物体在空间和时间中的运动。随着我们学习新的Fortran特性，我们将不断扩展和改进我们的应用程序，以生成更真实的模拟结果。本章介绍了函数和子程序，它们将帮助我们管理日益复杂的应用程序。&#xA;本章主要介绍了如何在保持简单性的同时扩展不断增长的应用程序。到目前为止，我们的最小工作应用程序是作为一个单一程序组织的，其中包含一些语句，程序依次执行。这是命令式编程的方式 - 您告诉计算机要做什么，一条语句接一条语句。这种方法之所以有效，是因为我们处理的问题相对简单。然而，现在我们将为更现实的流体动力学模拟做准备，这将需要更多的移动部件和复杂性。&#xA;这就是函数和子程序的用武之地。它们允许我们定义自包含且可重用的代码片段，我们可以在需要时调用它们，并使用不同的输入数据。过程是我们将在本书中一遍又一遍重复使用的基本构建模块。&#xA;3.1 迈向更高的应用程序复杂性 简单胜于复杂，复杂胜于混乱。&#xA;— Tim Peters，《Python之禅》&#xA;尽管这是Python的口头禅，但这句开场白同样适用于Fortran和一般编程。我们总是尽量保持简单。这在软件设计中尤为重要，因为我们经常处理越来越复杂的系统。简单易于阅读、理解，并且向我们的朋友和同事解释。然而，随着我们构建应用程序、库或框架，保持简单却是一项挑战。我们添加的功能越多，处理的特殊情况越多，我们的应用程序看起来就越臃肿，我们担心项目会失控。它不可避免地变得更加复杂。这是否意味着它必须变得更加复杂？&#xA;我没有传统的计算机科学背景。我最初学习编程是为了解决物理问题，就像我们在上一章中所做的那样。对我来说，编程更多地是一种解决给定任务的工具，而不是一种艺术。我的一些程序很容易就能增长到几千行代码，包含难以理解的读写二进制文件、嵌套循环和无尽的命令式表达式和赋值。没有函数调用，没有代码重用。用面向对象的类和方法抽象数据？别想了！这简直是程序员的噩梦。&#xA;随着时间的推移，我了解到Fortran专门设计的功能，使编程变得更容易。例如，您可以将重复的计算写成函数，并用不同的输入多次调用它。您可以使用Fortran 90标准引入的模块来定义变量和过程，然后可以从程序或库的其他位置访问它们。仔细组合这些元素，无论您更喜欢面向对象、函数式还是纯过程式的编程方法，都会让您的生活更轻松。&#xA;3.1.1 重构海啸模拟器 在上一章中，我们制作了一个初步可行的水波模拟器的第一个工作版本。它包含在一个单独的程序中，包括数据声明和初始化、算术表达式和赋值来计算解决方案、一个do循环来推进解决方案在时间上向前移动，以及一个打印语句来在每个时间步骤将结果输出到屏幕上。这是一个简单的程序，有26行代码，只做简单的事情：初始化水高度，模拟由于背景流动而向前移动的过程，并在每个时间步骤将其状态写入屏幕上（图3.1）。&#xA;图3.1 将一个高斯形状从左向右移动的过程。我们在上一章中解决了这个问题。&#xA;在本章中，我们将重构模拟器，使用一组常见的构建块，例如我在第2章介绍的有限差分计算。这将使我们能够更轻松地在接下来的章节中扩展模拟器，以便更接近更真实的水波运动。回顾我们前一章中解算器的核心，如下清单所示。&#xA;程序3.1 最小工作海啸模拟器中的时间积分循环&#xA;! 针对 num_time_steps 时间步进行迭代 time_loop: do n = 1, num_time_steps dh(1) = h(1) - h(grid_size) ! 计算左边界的差异 ! 计算其余区域的差异 do concurrent (i = 2:grid_size) dh(i) = h(i) - h(i-1) end do ! 计算并存储下一个时间步的h值 do concurrent (i = 1:grid_size) h(i) = h(i) - c * dh(i) / dx * dt end do end do time_loop 主循环（time_loop）的主体包括两个步骤：计算空间中水高度h的差异，并使用该差异来预测和存储其在下一个时间步的新值。这只解决了水高度的一个方程，其中包含一个物理项，即线性平流。</description>
    </item>
    <item>
      <title></title>
      <link>https://peakhan618.github.io/books/modernfortran/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://peakhan618.github.io/books/modernfortran/readme/</guid>
      <description>Modern Fortran 前言部分 第一部分 开始学习现代Fortran 第1章 介绍Fortran 第2章 入门：最小可行应用 第3章 使用函数和子程序编写可重用代码 附录A:设置Fortran开发环境 附录B：从微积分到代码 附录C:总结性说明 </description>
    </item>
    <item>
      <title>基本功能：数学公式</title>
      <link>https://peakhan618.github.io/tests/tests4blog/test2_math_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://peakhan618.github.io/tests/tests4blog/test2_math_test/</guid>
      <description>&lt;p&gt;本文旨在测试博客模板（mainroad）对数学公式输入的支持效果。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
